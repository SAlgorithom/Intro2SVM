%%% !Mode\dots "XeLaTeX:UTF-8"
%%% author : liuzheng712@gmail.com(刘正)
\documentclass[a4paper,12pt]{article}
\input{setup/package}
% 页眉设置
\geometry{left=2.5cm,right=2.5cm,bottom=2.5cm,top=3cm}

\begin{document}
\input{setup/format}
\cnarticle			% 中文论文环境，默认是英文的
%\renewcommand{\thefigure}{\arabic{section}-\arabic{figure}}       % 使图编号为 7-1 的格式 
%\renewcommand{\thesubfigure}{\alph{subfigure})}                   % 使子图编号为 a) 的格式
%\renewcommand{\thesubtable}{(\alph{subtable})}                    % 使子表编号为 (a) 的格式
%\renewcommand{\thetable}{\arabic{section}-\arabic{table}}         % 使表编号为 7-1 的格式
%\renewcommand{\theequation}{\arabic{section}-\arabic{equation}}   % 使公式编号为 7-1 的格式
\yemeiclean  % 清理页眉，注释掉会显示页眉

\begin{center}
\sihao   支持向量机通俗导论（理解SVM的三层境界）
\wuhao

作者：July、pluskid ；致谢：白石、JerryLead

出处：结构之法算法之道blog。

\end{center}
%\begin{multicols}{2}
\section*{前言}
动笔写这个支持向量机(support vector machine)是费了不少劲和困难的，原因很简单，一者这个东西本身就并不好懂，要深入学习和研究下去需花费不少时间和精力，二者这个东西也不好讲清楚，尽管网上已经有朋友写得不错了(见文末参考链接)，但在描述数学公式的时候还是显得不够。得益于同学白石的数学证明，我还是想尝试写一下，希望本文在兼顾通俗易懂的基础上，真真正正能足以成为一篇完整概括和介绍支持向量机的导论性的文章。

本文在写的过程中，参考了不少资料，包括《支持向量机导论》、《统计学习方法》及网友pluskid的支持向量机系列等等，于此，还是一篇学习笔记，只是加入了自己的理解和总结，有任何不妥之处，还望海涵。全文宏观上整体认识支持向量机的概念和用处，微观上深究部分定理的来龙去脉，证明及原理细节，力保逻辑清晰 \& 通俗易懂。

同时，阅读本文时建议大家尽量使用chrome等浏览器，如此公式才能更好的显示，再者，阅读时可拿张纸和笔出来，把本文所有定理.公式都亲自推导一遍或者直接打印下来（可直接打印网页版或本文文末附的PDF，享受随时随地思考、演算的极致快感），在文稿上演算。

Ok，还是那句原话，有任何问题，欢迎任何人随时不吝指正 \& 赐教，感谢。

\section{第一层、了解SVM}
\subsection{什么是支持向量机SVM}
要明白什么是SVM，便得从分类说起。

分类作为数据挖掘领域中一项非常重要的任务，它的目的是学会一个分类函数或分类模型(或者叫做分类器)，而支持向量机本身便是一种监督式学习的方法(至于具体什么是监督学习与非监督学习，请参见此系列Machine L\&Data Mining第一篇)，它广泛的应用于统计分类以及回归分析中。

支持向量机（SVM）是90年代中期发展起来的基于统计学习理论的一种机器学习方法，通过寻求结构化风险最小来提高学习机泛化能力，实现经验风险和置信范围的最小化，从而达到在统计样本量较少的情况下，亦能获得良好统计规律的目的。

通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。

对于不想深究SVM原理的同学或比如就只想看看SVM是干嘛的，那么，了解到这里便足够了，不需上层。而对于那些喜欢深入研究一个东西的同学，甚至究其本质的，咱们则还有很长的一段路要走，万里长征，咱们开始迈第一步吧，相信你能走完。

\subsection{线性分类}
OK，在讲SVM之前，咱们必须先弄清楚一个概念：线性分类器(也可以叫做感知机，这里的机表示的是一种算法，本文第三部分、证明SVM中会详细阐述)。

\subsubsection{分类标准}
  这里我们考虑的是一个两类的分类问题，数据点用 $ x $ 来表示，这是一个 $ n $ 维向量，$ w^T $中的$ T $代表转置，而类别用 $ y $ 来表示，可以取 1 或者 -1 ，分别代表两个不同的类。一个线性分类器的学习目标就是要在 $ n $ 维的数据空间中找到一个分类超平面，其方程可以表示为：

\begin{equation}
w^Tx+b=0
\end{equation}

上面给出了线性分类的定义描述，但或许读者没有想过：为何用y取1 或者 -1来表示两个不同的类别呢？其实，这个1或-1的分类标准起源于logistic回归，为了完整和过渡的自然性，咱们就再来看看这个logistic回归。

\subsubsection{1或-1分类标准的起源：logistic回归}
Logistic回归目的是从特征学习出一个$0/1$分类模型，而这个模型是将特性的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷。因此，使用logistic函数（或称作sigmoid函数）将自变量映射到 $ (0,1) $ 上，映射后的值被认为是属于y=1的概率。

形式化表示就是

假设函数
\begin{equation}
h_0(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}
\end{equation}

其中$x$是$n$维特征向量，函数$g$就是logistic函数。

而$g(z)=\frac{1}{1+e^{-z}}$的图像是

\begin{figure}[H]
\centering
\includegraphics[width=7cm]{fig1}
\end{figure}

可以看到，将无穷映射到了$(0,1)$。

而假设函数就是特征属于$y=1$的概率。
\begin{equation}
P(y=1|x;\theta)=h_\theta(x)
P(y=0|x;\theta)=1-h_\theta(x)
\end{equation}

当我们要判别一个新来的特征属于哪个类时，只需求，若大于$0.5$就是$y=1$的类，反之属于$y=0$类。

再审视一下$h_\theta(x)$，发现$h_\theta(x)$只和$ \theta^T $有关，$\theta^Tx>0$，那么$h_\theta(x)>0.5$，$g(z)$只不过是用来映射，真实的类别决定权还在$\theta^Tx$。还有当时$\theta^Tx>>0$，$h_\theta(x)=1$，反之$h_\theta(x)=0$。如果我们只从$\theta^Tx$出发，希望模型达到的目标无非就是让训练数据中$y=1$的特征$$\theta^Tx>>0$$，而是$y=0$的特征$\theta^Tx<<0$。Logistic回归就是要学习得到$\theta$，使得正例的特征远大于$0$，负例的特征远小于$0$，强调在全部训练实例上达到这个目标。

\subsubsection{形式化标示}
我们这次使用的结果标签是$y=-1$,$y=1$，替换在logistic回归中使用的$y=0$和$y=1$。同时将$\theta$替换成$w$和$b$。以前的$\theta^Tx=\theta_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n$，其中认为$x_0=1$。现在我们替换为$b$，后面替换$\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n$为$w_1x_1+w_2x_2+\cdots+w_nx_n$（即$x^Tx$）。这样，我们让$\theta^Tx=w^Tx+b$，进一步$h_\theta(x)=g(\theta^Tx)=g(w^Tx+b)$。也就是说除了$y$由$y=0$变为$y=-1$，只是标记不同外，与logistic回归的形式化表示没区别。

再明确下假设函数
\begin{equation}
h_{w,b}=g(w^Tx+b)
\end{equation}

上面提到过我们只需考虑$\theta^Tx$的正负问题，而不用关心$g(z)$，因此我们这里将$g(z)$做一个简化，将其简单映射到$y=-1$和$y=1$上。映射关系如下：

\begin{equation}
g(z)=\left\{\begin{array}{lr}
1, &z\geqslant0\\
-1, &z<0
\end{array}\right.
\end{equation}

于此，想必已经解释明白了为何线性分类的标准一般用$1$ 或者$-1$ 来标示。

注：上小节来自jerrylead所作的斯坦福机器学习课程的笔记。

\subsection{线性分类的一个例子}
下面举个简单的例子，一个二维平面(一个超平面，在二维空间中的例子就是一条直线)，如下图所示，平面上有两种不同的点，分别用两种不同的颜色表示，一种为红颜色的点，另一种则为蓝颜色的点，红颜色的线表示一个可行的超平面。
\begin{figure}[H]
\centering
\includegraphics[width=6cm]{fig2}
\end{figure}

从上图中我们可以看出，这条红颜色的线把红颜色的点和蓝颜色的点分开来了。而这条红颜色的线就是我们上面所说的超平面，也就是说，这个所谓的超平面的的确确便把这两种不同颜色的数据点分隔开来，在超平面一边的数据点所对应的 $y$全是 $-1$ ，而在另一边全是 $1$ 。

接着，我们可以令分类函数（提醒：下文很大篇幅都在讨论着这个分类函数）：

\begin{equation}
f(x)=w^Tx+b
\end{equation}

显然，如果 $f(x)=0$ ，那么 $x$ 是位于超平面上的点。我们不妨要求对于所有满足 $f(x)<0$ 的点，其对应的 $y$ 等于 $-1$ ，而 $f(x)>0$ 则对应 $y=1$ 的数据点。

\begin{figure}[H]
\centering
\includegraphics[width=6cm]{fig3}
\end{figure}

注：上图中，定义特征到结果的输出函数$u=\vec w \cdot \vec x -b$，与我们之前定义的$f(x)=w^Tx+b$实质是一样的。为什么？因为无论是$u=\vec w \cdot \vec x -b$，还是$f(x)=w^Tx+b$，不影响最终优化结果。下文你将看到，当我们转化到优化$\max\frac{1}{\|w\|},s.t.,y_i(w^Tx_i+b)\geq1,i=1,\cdots ,n$的时候，为了求解方便，会把$yf(x)$令为$1$，即$yf(x)$是$y(w^x + b)$，还是$y(w^x - b)$，对我们要优化的式子$\max\frac{1}{\|w\|}$已无影响。

（有一朋友飞狗来自Mare Desiderii，看了上面的定义之后，问道：请教一下SVM functional margin 为$ \widehat{\gamma}=y(wTx+b)=yf(x)$中的$\gamma$
是只取$1$和$-1$ 吗？$y$的唯一作用就是确保functional margin的非负性？真是这样的么？当然不是，详情请见本文评论下第43楼）

当然，有些时候，或者说大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在(不过关于如何处理这样的问题我们后面会讲)，这里先从最简单的情形开始推导，就假设数据都是线性可分的，亦即这样的超平面是存在的。
    
更进一步，我们在进行分类的时候，将数据点 $x$代入 $f(x)$ 中，如果得到的结果小于 $0$ ，则赋予其类别$ -1$ ，如果大于 $0$ 则赋予类别 $1$ 。如果 $f(x)=0$，则很难办了，分到哪一类都不是。

请读者注意，下面的篇幅将按下述3点走：
\begin{enumerate}
\item 咱们就要确定上述分类函数$f(x) = w\cdot x + b$（$w\cdot x$表示w与x的内积）中的两个参数$w$和$b$，通俗理解的话$w$是法向量，$b$是截距（再次说明：定义特征到结果的输出函数$u=\vert w\cdot \vert x-b$，与我们最开始定义的$f(x)=w^Tx+b$实质是一样的）；
\item 那如何确定$w$和$b$呢？答案是寻找两条边界端或极端划分直线中间的最大间隔（之所以要寻最大间隔是为了能更好的划分不同类的点，下文你将看到：为寻最大间隔，导出$1/2||w||^2!!!!!!!!!!!!!!!!!!!!!$，继而引入拉格朗日函数和对偶变量$a$，化为对单一因数对偶变量$a$的求解，当然，这是后话），从而确定最终的最大间隔分类超平面hyper plane和分类函数；
\item 进而把寻求分类函数$f(x) = w\cdot x + b$的问题转化为对$w$，$b$的最优化问题，最终化为对偶因子的求解。
\end{enumerate}

总结成一句话即是：从最大间隔出发（目的本就是为了确定法向量$w$），转化为求对变量$w$和$b$的凸二次规划问题。亦或如下图所示（有点需要注意，如读者@酱爆小八爪所说：从最大分类间隔开始，就一直是凸优化问题）：
\begin{figure}[H]
\centering
\includegraphics[width=13cm]{fig4}
\end{figure}

\subsection{函数间隔Functional margin与几何间隔Geometrical margin }

一般而言，一个点距离超平面的远近可以表示为分类预测的确信或准确程度。

\begin{itemize}
\item 在超平面$w*x+b=0$确定的情况下，$|w*x+b|$能够相对的表示点x到距离超平面的远近，而$w*x+b$的符号与类标记$y$的符号是否一致表示分类是否正确，所以，可以用量$y*(w*x+b)$的正负性来判定或表示分类的正确性和确信度。
\end{itemize}
于此，我们便引出了定义样本到分类间隔距离的函数间隔functional margin的概念。

\subsubsection{函数间隔Functional margin}
我们定义函数间隔functional margin 为： 

\begin{equation}
\widehat{\gamma}=y(w^Tx+b)=yf(x)
\end{equation}

接着，我们定义超平面$(w,b)$关于训练数据集T的函数间隔为超平面$(w,b)$关于T中所有样本点$(x_i,y_i)$的函数间隔最小值，其中，$x$是特征，$y$是结果标签，$i$表示第$i$个样本，有：
\begin{equation}
\widehat{\gamma}=\min\widehat{\gamma}_i(i=1,\cdots,n)
\end{equation}

然与此同时，问题就出来了。上述定义的函数间隔虽然可以表示分类预测的正确性和确信度，但在选择分类超平面时，只有函数间隔还远远不够，因为如果成比例的改变$w$和$b$，如将他们改变为$2w$和$2b$，虽然此时超平面没有改变，但函数间隔的值$f(x)$却变成了原来的$2$倍。

其实，我们可以对法向量$w$加些约束条件，使其表面上看起来规范化，如此，我们很快又将引出真正定义点到超平面的距离--几何间隔geometrical margin的概念（很快你将看到，几何间隔就是函数间隔除以个$\|w\|$，即$yf(x) / \|w\|$）。

\subsubsection{点到超平面的距离定义：几何间隔Geometrical margin}
\begin{figure}[H]
\centering
\includegraphics[width=13cm]{fig5}
\end{figure}

在给出几何间隔的定义之前，咱们首先来看下，如上图所示，对于一个点 $x$ ，令其垂直投影到超平面上的对应的为 $x_0$ ，由于 $w$ 是垂直于超平面的一个向量，$\gamma$为样本$x$到分类间隔的距离，我们有

\begin{equation}
x=x_0+\gamma\frac{w}{\|w\|}
\end{equation}

又由于$ x_0$ 是超平面上的点，满足 $f(x_0)=0$ ，代入超平面的方程即可算出： 
\begin{equation}
\gamma=\frac{w^Tx+b}{\|w\|}=\frac{f(x)}{\|w\|}
\end{equation}
（有的书上会写成把$\|w\|$ 分开相除的形式，如本文参考文献及推荐阅读条目11，其中，$\|w\|$为$w$的二阶泛数）

不过这里的$\gamma$是带符号的，我们需要的只是它的绝对值，因此类似地，也乘上对应的类别 $y$即可，因此实际上我们定义 几何间隔geometrical margin 为(注：别忘了，上面$\widehat{\gamma}$的定义，$\widehat{\gamma}=y(w^Tx+b)=yf(x)$ )：
\begin{equation}
  \widetilde{\gamma}=y\gamma=\frac{\widehat{\gamma}}{\|w\|}
\end{equation}
\begin{center}
（代入相关式子可以得出：yi*(w/||w|| + b/||w||)）
\end{center}

正如本文评论下读者popol1991留言：函数间隔$y*(wx+b)=y*f(x)$实际上就是$|f(x)|$，只是人为定义的一个间隔度量；而几何间隔$|f(x)|/\|w\|$才是直观上的点到超平面距离。

想想二维空间里的点到直线公式：假设一条直线的方程为$ax+by+c=0$,点$P$的坐标是$(x_0,y_0)$，则点到直线距离为$|ax_0+by_0+c|/sqrt(a^2+b^2)$。如下图所示：

点到平面的距离

若点坐标为$(x_0.y_0.z_0)$，平面为$Ax+By+Cz+D=0$，则点到平面的距离为：

\begin{equation}
  d=\left|\frac{Ax_0+By_0+Cz_0+D}{\sqrt{A^2+B^2+C^2}}\right|
\end{equation}

那么如果用向量表示，设$w=(a,b)$,$f(x)=wx+c$,那么这个距离正是$|f(p)|/\|w\|$。

\subsection{最大间隔分类器Maximum Margin Classifier的定义}

于此，我们已经很明显的看出，函数间隔functional margin 和 几何间隔geometrical margin 相差一个的缩放因子。按照我们前面的分析，对一个数据点进行分类，当它的 margin 越大的时候，分类的 confidence 越大。对于一个包含$ n $个点的数据集，我们可以很自然地定义它的 margin 为所有这$ n $个点的 margi$n $值中最小的那个。于是，为了使得分类的 confidence 高，我们希望所选择的超平面hyper plane 能够最大化这个 margin 值。

\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{fig6}
\end{figure}
通过上节，我们已经知道：

1、functional margin 明显是不太适合用来最大化的一个量，因为在 hyper plane 固定以后，我们可以等比例地缩放 $w$ 的长度和$ b $的值，这样可以使得$f(x)=w^Tx+b$的值任意大，亦即 functional margin$\widehat{\gamma}$可以在 hyper plane 保持不变的情况下被取得任意大，

2、而 geometrical margin 则没有这个问题，因为除上了$\|w\|$这个分母，所以缩放 $w$ 和 $b$ 的时候的值是不会改变的，它只随着 hyper plane 的变动而变动，因此，这是更加合适的一个 margin 。

这样一来，我们的 maximum margin classifier 的目标函数可以定义为：

\begin{equation}
  \max\widetilde{\gamma}
\end{equation}

当然，还需要满足一些条件，根据 margin 的定义，我们有
\begin{equation}
  y_i(w^Tx_i+b)=\widehat{\gamma_i}\geq\widehat{\gamma},i=1,\cdots,n
\end{equation}

其中$\widehat{\gamma}=\widetilde{\gamma}\|w\|$ (等价于$\widetilde{\gamma}=\gamma/\|w\|$，故有稍后的$\widehat{\gamma}  =1$ 时，$\widetilde{\gamma}  = 1 / \|w\|$)，处于方便推导和优化的目的，我们可以令$\widehat{\gamma}=1$(对目标函数的优化没有影响，至于为什么，请见本文评论下第42楼回复) ，此时，上述的目标函数$\widetilde{\gamma}$转化为(其中，s.t.，即subject to的意思，它导出的是约束条件)：

\begin{equation}
  \max\frac{1}{\|w\|},w.t.,y_i(w^Tx_i+b)\geq1,i=1,\cdots,n
\end{equation}

通过求解这个问题，我们就可以找到一个 margin 最大的 classifier ，如下图所示，中间的红色线条是 Optimal Hyper Plane ，另外两条线到红线的距离都是等于$\widetilde{\gamma}$的($\widetilde{\gamma}$便是上文所定义的geometrical margin，当令$\widehat{\gamma}=1$时，$\widetilde{\gamma}$便为$1/\|w\|$，而我们上面得到的目标函数便是在相应的约束条件下，要最大化这个$1/\|w\|$值)：

\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{fig7}
\end{figure}
通过最大化 margin ，我们使得该分类器对数据进行分类时具有了最大的 confidence，从而设计决策最优分类超平面。

\subsection{到底什么是Support Vector}
上节，我们介绍了Maximum Margin Classifier，但并没有具体阐述到底什么是Support Vector，本节，咱们来重点阐述这个概念。咱们不妨先来回忆一下上节1.4节最后一张图：
\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{fig8}
\end{figure}

可以看到两个支撑着中间的 gap 的超平面，它们到中间的纯红线separating hyper plane 的距离相等，即我们所能得到的最大的 geometrical margin$\widetilde{\gamma}$，而“支撑”这两个超平面的必定会有一些点，而这些“支撑”的点便叫做支持向量Support Vector。

或亦可看下来自此PPT中的一张图，Support Vector便是那蓝色虚线和粉红色虚线上的点：

\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{fig9}
\end{figure}

很显然，由于这些 supporting vector 刚好在边界上，所以它们满足$y(w^Tx+b)=1$（还记得我们把 functional margin 定为 1 了吗？上节中：“处于方便推导和优化的目的，我们可以令$\widehat{\gamma}=1$”），而对于所有不是支持向量的点，也就是在“阵地后方”的点，则显然$y(w^Tx+b)>1$有。当然，除了从几何直观上之外，支持向量的概念也可以从下文优化过程的推导中得到。

OK，到此为止，算是了解到了SVM的第一层，对于那些只关心怎么用SVM的朋友便已足够，不必再更进一层深究其更深的原理。

\section{深入SVM}
\subsection{从线性可分到线性不可分}
\subsubsection{从原始问题到对偶问题的求解}
虽然上文1.4节给出了目标函数，却没有讲怎么来求解。现在就让我们来处理这个问题。回忆一下之前得到的目标函数（subject to导出的则是约束条件）：
\begin{equation}
  \max\frac{1}{\|w\|}\,s.t.,y_i(w^Tx_i+b)\geq1,i=1,\cdots,n
\end{equation}

由于求$\frac{1}{\|w\|}$的最大值相当于求$\frac{1}{2}\|w\|^2$的最小值，所以上述问题等价于（$w$由分母变成分子，从而也有原来的$\max$问题变为$\min$问题，很明显，两者问题等价）：
\begin{equation}
  \min\frac{1}{2}\|w\|^2\,s.t.,y_i(w^Tx_i+b)\geq1,i=1,\cdots,n
\end{equation}
\begin{itemize}
\item 转化到这个形式后，我们的问题成为了一个凸优化问题，或者更具体的说，因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。这个问题可以用任何现成的 QP (Quadratic Programming) 的优化包进行求解，归结为一句话即是：在一定的约束条件下，目标最优，损失最小；
\item 但虽然这个问题确实是一个标准的 QP 问题，但是它也有它的特殊结构，通过 Lagrange Duality 变换到对偶变量 (dual variable) 的优化问题之后，可以找到一种更加有效的方法来进行求解，而且通常情况下这种方法比直接使用通用的 QP 优化包进行优化要高效得多。
\end{itemize}

也就说，除了用解决QP问题的常规方法之外，还可以通过求解对偶问题得到最优解，这就是线性可分条件下支持向量机的对偶算法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数，进而推广到非线性分类问题。

至于上述提到，关于什么是Lagrange duality？简单地来说，通过给每一个约束条件加上一个 Lagrange multiplier(拉格朗日乘值)，即引入拉格朗日乘子$\alpha$如此我们便可以通过拉格朗日函数将约束条件融和到目标函数里去(也就是说把条件融合到一个函数里头，现在只用一个函数表达式便能清楚的表达出我们的问题)：
\begin{equation}
  \mathcal{L}(w,b,\alpha)=\frac{1}{2}\|w\|^2-\sum_{i=1}^n\alpha_i\left(y_i(w^Tx_i+b)-1\right)
\end{equation}
然后我们令
\begin{equation}
  \theta(w)=\max_{\alpha_i\geq0}\mathcal{L}(w,b,\alpha)
\end{equation}

容易验证，当某个约束条件不满足时，例如$y_i(w^Tx_i+b)<1$，那么我们显然有$\theta(w)=\inf$（只要令$\alpha_i=\inf$即可）。而当所有约束条件都满足时，则有$\theta(w)=\frac{1}{2}\|w\|^2$，亦即我们最初要最小化的量。因此，在要求约束条件得到满足的情况下最小化$\frac{1}{2}\|w\|^2$，实际上等价于直接最小化$\theta(w)$（当然，这里也有约束条件，就是$\alpha_i\geq0,i=1,\cdots,n$），因为如果约束条件没有得到满足，$\theta{w}$等于无穷大，自然不会是我们所要求的最小值。具体写出来，我们现在的目标函数变成了：
\begin{equation}
  \min_{w,b}\theta(w)=\min_{w,b}\max_{\alpha_i\geq0}\mathcal{L}(w,b,\alpha)=p^*
\end{equation}

 这里用$p^*$表示这个问题的最优值，这个问题和我们最初的问题是等价的。不过，现在我们来把最小和最大的位置交换一下（稍后，你将看到，当下面式子满足了一定的条件之后，这个式子$d$ 便是上式$P$ 的对偶形式表示）：
 
\begin{equation}
  \max_{\alpha_i\geq0}\min_{w,b}\mathcal{L}(w,b,\alpha)=d^*
\end{equation}

当然，交换以后的问题不再等价于原问题，这个新问题的最优值用$d^*$来表示。并且，我们有$d^*\leq p^*$ ，这在直观上也不难理解，最大值中最小的一个总也比最小值中最大的一个要大吧！  总之，第二个问题的最优值$d^*$在这里提供了一个第一个问题的最优值$p^*$的一个下界，在满足某些条件的情况下，这两者相等，这个时候我们就可以通过求解第二个问题来间接地求解第一个问题。

也就是说，下面我们将先求$L$ 对$w$、$b$的极小，再求$L$ 对$\alpha$的极大。而且，之所以从$\min\max$的原始问题$p^*$，转化为$\max\min$的对偶问题$d^*$，一者因为$d^*$是$p^*$的近似解，二者，转化为对偶问题后，更容易求解。

\subsubsection{KKT条件}
与此同时，上段说“在满足某些条件的情况下”，这所谓的“满足某些条件”就是要满足KKT条件。那KKT条件的表现形式是什么呢？据维基百科：KKT 条件的介绍，一般地，一个最优化数学模型能够表示成下列标准形式：
\begin{equation}
\begin{split}
  \min.f(x)\\
  s.t. h_j(x)&=0,j=1,\cdots,p,\\
  g_k(x)&\leq0,k=1,\cdots,q,\\
  x\in X&\subset\Re^n
\end{split}
\end{equation}
其中，$f(x)$是需要最小化的函数，$h(x)$是等式约束，$g(x)$是不等式约束，$p$和$q$分别为等式约束和不等式约束的数量。同时，我们得明白以下两个定理：
\begin{itemize}
  \item 凸优化的概念：$\mathcal{X} \subset \mathbb{R}^n$ 为一凸集， $f:\mathcal{X}\to \mathbb{R}$ 为一凸函数。凸优化就是要找出一点 $x^\ast \in \mathcal{X}$ ，使得每一 $x \in \mathcal{X} $满足 $f(x^\ast)\le f(x) $。
  \item KKT条件的意义：它是一个非线性规划（Nonlinear Programming）问题能有最优化解法的必要和充分条件。
\end{itemize}

那到底什么是所谓Karush-Kuhn-Tucker条件呢？KKT条件就是指上面最优化数学模型的标准形式中的最小点 $x^*$ 必须满足下面的条件：

\begin{equation}
  \begin{split}
  1.\;h_j(x_*)=0,j=1,\cdots,p,g_k(x_*)\leq0,k=1,\cdots,q,\\
  2.\;\nabla f(x_*)+\sum_{j=1}^p\lambda_j\nabla h_j(x_*)+\sum_{k=1}^q\mu_k\nabla g_k(x_*)=0,\\
  \lambda\neq0m\mu_k\geq0,\mu_kg_k(x_*)=0
\end{split}
\end{equation}
经过论证，我们这里的问题是满足 KKT 条件的（首先已经满足Slater condition，再者$f$和$g_i$也都是可微的，即$L$对$w$和$b$都可导），因此现在我们便转化为求解第二个问题。也就是说，现在，咱们的原问题通过满足一定的条件，已经转化成了对偶问题。而求解这个对偶学习问题，分为3个步骤，首先要让L(w，b，a) 关于 w 和 b 最小化，然后求对α的极大，最后利用SMO算法求解对偶因子。

\subsubsection{对偶问题求解的3个步骤}
（1）、首先固定，要让$ L$ 关于 $w$ 和 $b$ 最小化，我们分别对$w$，$b$求偏导数，即令 $\partial\mathcal{L}/\partial w$ 和 $\partial\mathcal{L}/\partial b$ 等于零（对$w$求导结果的解释请看本文评论下第45楼回复）：
\begin{equation}
  \begin{split}
    \frac{\mathcal{L}}{\partial w}= &\Rightarrow w=\sum_{i=1}^n\alpha_iy_ix_i\\
    \frac{\mathcal{L}}{\partial b}= &\Rightarrow w=\sum_{i=1}^n\alpha_iy_i=0
  \end{split}
\end{equation}

以上结果代回上述的$\mathcal{L}$：
\begin{equation}
  \mathcal{L}(w,b,\alpha)=\frac{1}{2}\|w\|^2-\sum_{i=1}^n\alpha_i\left(y_i(w^Tx_i+b)-1\right)
\end{equation}
得到：
\begin{equation}
  \begin{split}
    \mathcal{L}(w,b,\alpha)&=\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum_{i=1}^n\alpha_iy_i+\sum_{i=1}^n\alpha_i\\
    &=\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j
  \end{split}
\end{equation}

提醒：有读者可能会问上述推导过程如何而来？说实话，其具体推导过程是比较复杂的，如下图所示：
\begin{equation}
  \begin{split}
    \mathcal{L}(w,b,\alpha)&=\frac{1}{2}\|w\|^2-\sum_{i=1}^m\alpha_i[y^{(i)}(w^Tx^{(i)}+b)-1]\\
    &=\frac{1}{2}w^Tw-\sum_{i=1}^m\alpha_iy^{(i)}w^Tx^{(i)}-\sum_{i=1}^m\alpha_iy^{(i)}b+\sum_{i=1}^m\alpha_i\\
    &=\frac{1}{2}w^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-\sum_{i=1}^m\alpha_iy^{(i)}w^Tx^{(i)}-\sum_{i=1}^m\alpha_iy^{(i)}b+\sum_{i=1}^m\alpha_i\\
    &=\frac{1}{2}w^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-w^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-\sum_{i=1}^m\alpha_iy^{(i)}b+\sum_{i=1}^m\alpha_i\\
    &=-\frac{1}{2}w^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-\sum_{i=1}^m\alpha_iy^{(i)}b+\sum_{i=1}^m\alpha_i\\
    &=-\frac{1}{2}w^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-b\sum_{i=1}^m\alpha_iy^{(i)}+\sum_{i=1}^m\alpha_i\\
    &=-\frac{1}{2}\left(\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}\right)^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-b\sum_{i=1}^m\alpha_iy^{(i)}+\sum_{i=1}^m\alpha_i\\
  &=-\frac{1}{2}\sum_{i=1}^m\alpha_iy^{(i)}\left(x^{(i)}\right)^T\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}-b\sum_{i=1}^m\alpha_iy^{(i)}+\sum_{i=1}^m\alpha_i\\
  &=-\frac{1}{2}\sum_{i,j=1}^m\alpha_iy^{(i)}\left(x^{(i)}\right)^T\alpha_jy^{(j)}x^{(j)}-b\sum_{i=1}^m\alpha_iy^{(i)}+\sum_{i=1}^m\alpha_i\\
  \end{split}
\end{equation}

最后，得到：
\begin{equation}
  \begin{split}
    \mathcal{L}(w,b,\alpha)&=\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j-b\sum_{i=1}^n\alpha_iy_i+\sum_{i=1}^n\alpha_i\\
    &=\sum_{i=1}^n\alpha_i-\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j
  \end{split}
\end{equation}

如 jerrylead所说：“倒数第4步”推导到“倒数第3步”使用了线性代数的转置运算，由于ai和yi都是实数，因此转置后与自身一样。“倒数第3步”推导到“倒数第2步”使$(a+b+c+…(a+b+c+\cdots)=aa+ab+ac+ba+bb+bc+\cdots$的乘法运算法则。最后一步是上一步的顺序调整。

  从上面的最后一个式子，我们可以看出，此时的拉格朗日函数只包含了一个变量，那就是$\alpha_i$，然后下文的第2步，求出了$\alpha_i$便能求出$w$，和$b$，由此可见，上文第1.2节提出来的核心问题：分类函数$f(x)=w^Tx+b$也就可以轻而易举的求出来了。

（2）、求对$\alpha$的极大，即是关于对偶问题的最优化问题，从上面的式子得到：

(不得不提醒下读者：经过上面第一个步骤的求$w$和$b$，得到的拉格朗日函数式子已经没有了变量$w$，$b$，只有$\alpha$，而反过来，求得的$\alpha$将能导出$w$，$b$的解，最终得出分离超平面和分类决策函数。为何呢？因为如果求出了$\alpha_i$，根据$w=\sum_{i=1}^m\alpha_iy^{(i)}x^{(i)}$，即可求出$w$。然后通过
$b^*=-\frac{\max_{i:y^{(i)}=-1}w^{*T}x^{(i)}+\min_{i:y^{(i)}=1}w^{*T}x^{(i)}}{2}$，即可求出$b$ )
\begin{equation}
  \begin{split}
    \max_\alpha\sum_{i=1}^n\alpha_i-\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx_i^Tx_j\\
    s.t,\alpha_i\geq0,i=1,\cdots,n\\
   \sum_{i=1}^n\alpha_iy_i=0
  \end{split}
\end{equation}
如前面所说，这个问题有更加高效的优化算法，即我们常说的SMO算法。
\subsubsection{序列最小最优化SMO算法}
细心的读者读至上节末尾处，怎么拉格朗日乘子的值可能依然心存疑惑。实际上，关于的求解可以用一种快速学习算法即SMO算法，这里先简要介绍下。

OK，当：
\begin{equation}
  \begin{split}
    \max_\alpha W(\alpha)=\sum_{i=1}^m\alpha_i-\frac{1}{2}\sum_{i,j=1}^my^{(i)}y^{(j)}\alpha_i\alpha_j\langle x^{(i)},x^{(j)}\rangle\\
    s.t.\; 0\leq\alpha_i\leq C,i=1,\cdots,m\\
    \sum_{i=1}^m\alpha_iy^{(i)}=0
  \end{split}
\end{equation}
要解决的是在参数$\{\alpha_1,\alpha_2,\cdots,\alpha_n\}$上求最大值$W$的问题，至于$x^{(i)}$和$y^{(i)}$都是已知数（其中$C$是一个参数，用于控制目标函数中两项（“寻找 margin 最大的超平面”和“保证数据点偏差量最小”）之间的权重。和上文最后的式子对比一下，可以看到唯一的区别就是现在 dual variablei$\alpha$多了一个上限$C$，关于$C$的具体由来请查看下文第2.3节）。

要了解这个SMO算法是如何推导的，请跳到下文第3.5节、SMO算法。

\subsubsection{线性不可分的情况}
OK，为过渡到下节2.2节所介绍的核函数，让我们再来看看上述推导过程中得到的一些有趣的形式。首先就是关于我们的 hyper plane ，对于一个数据点$ x$ 进行分类，实际上是通过把 $x$ 带入到$f(x)=w^Tx+b$算出结果然后根据其正负号来进行类别划分的。而前面的推导中我们得到 

\begin{equation}
  w=\sum_{i=1}^n\alpha_iy_ix_i
\end{equation}

因此分类函数为：
\begin{equation}
  \begin{split}
    f(x)&=\left(\sum_{i=1}^n\alpha_iy_ix_i\right)^Tx+b\\
    &=\sum_{i=1}^n\alpha_iy_i\langle x_i,x\rangle+b
    \end{split}
  \end{equation}
这里的形式的有趣之处在于，对于新点$ x$的预测，只需要计算它与训练数据点的内积即可（$\langle*,*\rangle$表示向量内积），这一点至关重要，是之后使用 Kernel 进行非线性推广的基本前提。此外，所谓 Supporting Vector 也在这里显示出来——事实上，所有非Supporting Vector 所对应的系$\alpha$数都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”而不是所有的训练数据即可。

为什么非支持向量对应的$\alpha$等于零呢？直观上来理解的话，就是这些“后方”的点——正如我们之前分析过的一样，对超平面是没有影响的，由于分类完全有超平面决定，所以这些无关的点并不会参与分类问题的计算，因而也就不会产生任何影响了。

回忆一下我们2.1.1节中通过 Lagrange multiplier得到的目标函数：
\begin{equation}
  \max_{\alpha_i\geq0}\mathcal{L}(w,b,\alpha)=\max_{\alpha_i\geq0}\frac{1}{2}\|w\|^2-\sum_{i=1}^n\alpha_i\left(y_i(w^Tx_i+b)-1\right)
\end{equation}

注意到如果 $x_i$ 是支持向量的话，上式中红颜色的部分是等于 $0$ 的（因为支持向量的 functional margin 等于 1 ），而对于非支持向量来说，functional margin 会大于$ 1$ ，因此红颜色部分是大于零的，而$\alpha_i$又是非负的，为了满足最大化，$\alpha_i$必须等于 $0$ 。这也就是这些非Supporting Vector 的点的局限性。 

从1.5节到上述所有这些东西，便得到了一个maximum margin hyper plane classifier，这就是所谓的支持向量机（Support Vector Machine）。当然，到目前为止，我们的 SVM 还比较弱，只能处理线性的情况，不过，在得到了对偶dual 形式之后，通过 Kernel 推广到非线性的情况就变成了一件非常容易的事情了(相信，你还记得本节开头所说的：“通过求解对偶问题得到最优解，这就是线性可分条件下支持向量机的对偶算法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数，进而推广到非线性分类问题”)。

\subsection{核函数Kernel}
\subsubsection{特征空间的隐式映射：核函数}
咱们首先给出核函数的来头：

\begin{itemize}
  \item 在上文中，我们已经了解到了SVM处理线性可分的情况，而对于非线性的情况，SVM 的处理方法是选择一个核函数 $k(*,*)$ ，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。由于核函数的优良品质，这样的非线性扩展在计算量上并没有比原来复杂多少，这一点是非常难得的。当然，这要归功于核方法——除了 SVM 之外，任何将计算表示为数据点的内积的方法，都可以使用核方法进行非线性扩展。
\end{itemize}

也就是说，Minsky和Papert早就在20世纪60年代就已经明确指出线性学习器计算能力有限。为什么呢？因为总体上来讲，现实世界复杂的应用需要有比线性函数更富有表达能力的假设空间，也就是说，目标概念通常不能由给定属性的简单线性函数组合产生，而是应该一般地寻找待研究数据的更为一般化的抽象特征。

而下文我们将具体介绍的核函数则提供了此种问题的解决途径，从下文你将看到，核函数通过把数据映射到高维空间来增加第一节所述的线性学习器的能力，使得线性学习器对偶空间的表达方式让分类操作更具灵活性和可操作性。因为训练样例一般是不会独立出现的，它们总是以成对样例的内积形式出现，而用对偶形式表示学习器的优势在为在该表示中可调参数的个数不依赖输入属性的个数，通过使用恰当的核函数来替代内积，可以隐式得将非线性的训练数据映射到高维空间，而不增加可调参数的个数(当然，前提是核函数能够计算对应着两个输入特征向量的内积)。

1、简而言之：在线性不可分的情况下，支持向量机通过某种事先选择的非线性映射(核函数)将输入变量映射到一个高维特征空间，在这个空间中构造最优分类超平面。我们使用SVM进行数据集分类工作的过程首先是同预先选定的一些非线性映射将输入空间映射到高维特征空间(下图很清晰的表达了通过映射到高维特征空间，而把平面上本身不好分的非线性数据分了开来)：

\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{fig10}
\end{figure}
 使得在高维属性空间中有可能最训练数据实现超平面的分割，避免了在原输入空间中进行非线性曲面分割计算。SVM数据集形成的分类函数具有这样的性质：它是一组以支持向量为参数的非线性函数的线性组合，因此分类函数的表达式仅和支持向量的数量有关，而独立于空间的维度，在处理高维输入空间的分类时，这种方法尤其有效，其工作原理如下图所示：
 \begin{figure}[H]
   \centering
   \includegraphics[width=13cm]{fig11}
 \end{figure}
2、具体点说：在我们遇到核函数之前，如果用原始的方法，那么在用线性学习器学习一个非线性关系，需要选择一个非线性特征集，并且将数据写成新的表达形式，这等价于应用一个固定的非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器，因此，考虑的假设集是这种类型的函数：
\begin{equation}
  f(x)=\sum_{i=1}^Nw_i\phi_i(x)+b
\end{equation}

这里$\phi:x\rightarrow f$是从输入空间到某个特征空间的映射，这意味着建立非线性学习器分为两步：
\begin{enumerate}[1.~]
    \item 首先使用一个非线性映射将数据变换到一个特征空间F，
    \item 然后在特征空间使用线性学习器分类。
\end{enumerate}

在上文我提到过对偶形式，而这个对偶形式就是线性学习器的一个重要性质，这意味着假设可以表达为训练点的线性组合，因此决策规则可以用测试点和训练点的内积来表示：
\begin{equation}
  f(x)=\sum_{i=1}^l\alpha_iy_i\langle\phi(x_i)\cdot\phi(x)\rangle+b
\end{equation}

如果有一种方式可以在特征空间中直接计算内积$\langle\phi(x_i)\cdot\phi(x)\rangle$，就像在原始输入点的函数中一样，就有可能将两个步骤融合到一起建立一个非线性的学习器，这样直接计算法的方法称为核函数方法，于是，核函数便横空出世了。)

这里我直接给出一个定义：核是一个函数$K$，对所有$x$，$z\in X$，满足$K(x,z)=\langle\phi(x)\cdot\phi(z)\rangle$，这里$\phi$是从$X$到内积特征空间$F$的映射。)

3、总而言之，举个简单直接点的例子，如@Wind所说：如果不是用核技术，就会先计算线性映射$\phi(x_1)$和$\phi(x_2)$,然后计算这两个特征的内积，使用了核技术之后，先把$\phi(x_1)$和$\phi(x_2)$的通用表达式子：$\langle\phi(x_1),\phi(x_2)\rangle\geq K(\langle x_1,x_2\rangle)$计算出来，注意到这里的$\langle*,*\rangle$表示内积，$K(*,*)$就是对应的核函数，这个表达往往非常简单，所以计算非常方便。
 
 OK，接下来，咱们就进一步从外到里，来探探这个核函数的真面目。
 \subsubsection{核函数：如何处理非线性数据}
 在2.1节中我们介绍了线性情况下的支持向量机，它通过寻找一个线性的超平面来达到对数据进行分类的目的。不过，由于是线性方法，所以对非线性的数据就没有办法处理。举个例子来说，则是如下图所示的两类数据，分别分布为两个圆圈的形状，这样的数据本身就是线性不可分的，此时咱们该如何把这两类数据分开呢(下文将会有一个相应的三维空间图)？

 \begin{figure}[H]
   \centering
   \includegraphics[width=13cm]{fig12}
 \end{figure}

 事实上，上图所述的这个数据集，是用两个半径不同的圆圈加上了少量的噪音生成得到的，所以，一个理想的分界应该是一个“圆圈”而不是一条线（超平面）。如果用$X_1$ 和$X_2$ 来表示这个二维平面的两个坐标的话，我们知道一条二次曲线（圆圈是二次曲线的一种特殊情况）的方程可以写作这样的形式：

\begin{equation}
  a_1X_1+a_2X_1^2+ a_3X_2+a_4X_2^2+a_5X_1X_2+a_6=0
\end{equation}

 注意上面的形式，如果我们构造另外一个五维的空间，其中五个坐标的值分别为 $Z_1=X_1, Z_2=X^2_1, Z_3=X_2, Z_4=X^2_2, Z_5=X_1X_2$，那么显然，上面的方程在新的坐标系下可以写作：
\begin{equation}
  \sum_{i=1}^5a_iZ_i+a_6=0
\end{equation}

于新的坐标 $Z$ ，这正是一个 hyper plane 的方程！也就是说，如果我们做一个映射$\phi:\mathbb{R}^2\rightarrow\mathbb{R}^5$，将 $X$ 按照上面的规则映射为 $Z$ ，那么在新的空间中原来的数据将变成线性可分的，从而使用之前我们推导的线性分类算法就可以进行处理了。这正是 Kernel 方法处理非线性问题的基本思想。

再进一步描述 Kernel 的细节之前，不妨再来看看这个例子映射过后的直观例子。当然，你我可能无法把$ 5$ 维空间画出来，不过由于我这里生成数据的时候就是用了特殊的情形，具体来说，我这里的超平面实际的方程是这个样子（圆心在 $X_2$ 轴上的一个正圆）：
\begin{equation}
  \sum_{i=1}^5a_iZ_i+a_6=0
  I think this equation is wrong
\end{equation}

因此我只需要把它映射到 $Z_1=X^2_1, Z_2=X_2^2, Z_3=X_2$ 这样一个三维空间中即可，下图即是映射之后的结果，将坐标轴经过适当的旋转，就可以很明显地看出，数据是可以通过一个平面来分开的(pluskid：下面的gif 动画，先用 Matlab 画出一张张图片，再用 Imagemagick 拼贴成)：
%\animategraphics[autoplay,loop,width=13cm]{8}{fig}{1}{8}

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

现在让我们再回到 SVM 的情形，假设原始的数据时非线性的，我们通过一个映射$\phi(\cdot)$将其映射到一个高维空间中，数据变得线性可分了，这个时候，我们就可以使用原来的推导来进行计算，只是所有的推导现在是在新的空间，而不是原始空间中进行。当然，推导过程也并不是可以简单地直接类比的，例如，原本我们要求超平面的法向量 $w$ ，但是如果映射之后得到的新空间的维度是无穷维的（确实会出现这样的情况，比如后面会提到的 高斯核Gaussian Kernel ），要表示一个无穷维的向量描述起来就比较麻烦。于是我们不妨先忽略过这些细节，直接从最终的结论来分析，回忆一下，我们上一次2.1节中得到的最终的分类函数是这样的：
\begin{equation}
  f(x)=\sum_{i=1}^n\alpha_iy_i\langle x_i,x\rangle+b
\end{equation}
在则是在映射过后的空间，即：
\begin{equation}
  f(x)=\sum_{i=1}^n\alpha_iy_i\langle\phi(x_i),\phi(x)\rangle+b
\end{equation}

而其中的$\alpha$也是通过求解如下 dual 问题而得到的：

\begin{equation}
  \begin{split}
    \max_\alpha\sum_{i=1}^n\alpha_i-\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_j\langle\phi(x_i),\phi(x_j)\rangle\\
    s.t.\;,\alpha_i\geq0,i=1,\cdots,n\\
    \sum_{i=1}^n\alpha_iy_i=0
  \end{split}
\end{equation}

这样一来问题就解决了吗？似乎是的：拿到非线性数据，就找一个映射$\phi(\cdot)$，然后一股脑把原来的数据映射到新空间中，再做线性 SVM 即可。不过事实上没有这么简单！其实刚才的方法稍想一下就会发现有问题：在最初的例子里，我们对一个二维空间做映射，选择的新空间是原始空间的所有一阶和二阶的组合，得到了五个维度；如果原始空间是三维，那么我们会得到 19 维的新空间，这个数目是呈爆炸性增长的，这给$\phi(\cdot)$的计算带来了非常大的困难，而且如果遇到无穷维的情况，就根本无从计算了。所以就需要 Kernel 出马了。

不妨还是从最开始的简单例子出发，设两个向量$x_1=(\eta_1,\eta_2)^T$和$x_2=(\xi_1,\xi_2)^T$，而$\phi(\cdot)$即是到前面2.2.1节说的五维空间的映射，因此映射过后的内积为：
\begin{equation}
  \langle\phi(x_1),\phi(x_2)\rangle=\eta_1\xi_1+\eta_1^2\xi_1^2+\eta_2\xi_2+\eta_2^2\xi_2^2+\eta_1\eta_2\xi_1\xi_2
\end{equation}

（公式说明：上面的这两个推导过程中，所说的前面的五维空间的映射，这里说的前面便是文中2.2.1节的所述的映射方式，仔细看下2.2.1节的映射规则，再看那第一个推导，其实就是计算$x_1$，$x_2$各自的内积，然后相乘相加即可，第二个推导则是直接平方，去掉括号，也很容易推出来）

另外，我们又注意到：
\begin{equation}
  (\langle x_1,x_2\rangle+1)^2=2\eta_1\xi_1+\eta_1^2\xi_1^2+2\eta_2\xi_2+\eta_2^2\xi_2^2+2\eta_1\eta_2\xi_1\xi_2+1
\end{equation}
 二者有很多相似的地方，实际上，我们只要把某几个维度线性缩放一下，然后再加上一个常数维度，具体来说，上面这个式子的计算结果实际上和映射
 \begin{equation}
   \varphi(X_1,X_2)=(\sqrt{2}X_1,X_1^2,\sqrt{2}X_2,X_2^2,\sqrt{2}X_1X_2,1)^T
 \end{equation}

 之后的内积$\langle\varphi(x_1,\varphi(x_2))\rangle$的结果是相等的，那么区别在于什么地方呢？
 \begin{enumerate}[1.~]
   \item 一个是映射到高维空间中，然后再根据内积的公式进行计算；
   \item 而另一个则直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果。
 \end{enumerate}

（公式说明：上面之中，最后的两个式子，第一个算式，是带内积的完全平方式，可以拆开，然后，通过凑一个得到，第二个算式，也是根据第一个算式凑出来的）

回忆刚才提到的映射的维度爆炸，在前一种方法已经无法计算的情况下，后一种方法却依旧能从容处理，甚至是无穷维度的情况也没有问题。

我们把这里的计算两个向量在隐式映射过后的空间中的内积的函数叫做核函数 (Kernel Function) ，例如，在刚才的例子中，我们的核函数为：


\begin{equation}
  k(x_1,x_2)=(\langle x_1,x_2\rangle+1)^2
\end{equation}

 核函数能简化映射空间中的内积运算——刚好“碰巧”的是，在我们的 SVM 里需要计算的地方数据向量总是以内积的形式出现的。对比刚才我们上面写出来的式子，现在我们的分类函数为：
 \begin{equation}
   \sum_{i=1}^n\alpha_iy_ik(x_i,x)+b
 \end{equation}

 其中$\alpha$由如下 dual 问题计算而得：

 \begin{equation}
   \begin{split}
     \max\alpha\sum_{i=1}^n\alpha_i-\frac{1}{2}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jk(x_i,x_j)\\
     s.t.,\; \alpha_i\geq0,i=1,\cdots,n\\
     \sum_{i=1}^n\alpha_iy_i=0
   \end{split}
 \end{equation}

 这样一来计算的问题就算解决了，避开了直接在高维空间中进行计算，而结果却是等价的！当然，因为我们这里的例子非常简单，所以我可以手工构造出对应于$\phi(\cdot)$的核函数出来，如果对于任意一个映射，想要构造出对应的核函数就很困难了。

 \subsubsection{几个核函数}
  通常人们会从一些常用的核函数中选择（根据问题和数据的不同，选择不同的参数，实际上就是得到了不同的核函数），例如：
\begin{itemize}
  \item 多项式核$k(x_1,x_2)=(\langle x_1,x_2\rangle+R)^d$，显然刚才我们举的例子是这里多项式核的一个特例（$R = 1$，$d = 2$）。虽然比较麻烦，而且没有必要，不过这个核所对应的映射实际上是可以写出来的，该空间的维度是$(_d^{m+d})$，其中$m$ 是原始空间的维度。
  \item 高斯核$k(x_1,x_2)=\exp\left(-\frac{\|x_1-x_2\|^2}{2\sigma^2}\right)$，这个核就是最开始提到过的会将原始空间映射为无穷维空间的那个家伙。不过，如果$\sigma$选得很大的话，高次特征上的权重实际上衰减得非常快，所以实际上（数值上近似一下）相当于一个低维的子空间；反过来，如果$\sigma$得很小，则可以将任意的数据映射为线性可分——当然，这并不一定是好事，因为随之而来的可能是非常严重的过拟合问题。不过，总的来说，通过调控参$\sigma$数，高斯核实际上具有相当高的灵活性，也是使用最广泛的核函数之一。下图所示的例子便是把低维线性不可分的数据通过高斯核函数映射到了高维空间：
  \begin{figure}[H]
    \centering
    \includegraphics[width=13cm]{fig14}
  \end{figure}
\item 线性核$k(x_1,x_2)=\langle x_1,x_2\rangle$，这实际上就是原始空间中的内积。这个核存在的主要目的是使得“映射后空间中的问题”和“映射前空间中的问题”两者在形式上统一起来了(意思是说，咱们有的时候，写代码，或写公式的时候，只要写个模板或通用表达式，然后再代入不同的核，便可以了，于此，便在形式上统一了起来，不用再分别写一个线性的，和一个非线性的)。
  \end{itemize}

\subsubsection{核函数的本质}

上面说了这么一大堆，读者可能还是没明白核函数到底是个什么东西？我再简要概括下，即以下三点：
\begin{enumerate}[1.~]
  \item 实际中，我们会经常遇到线性不可分的样例，此时，我们的常用做法是把样例特征映射到高维空间中去(如上文2.2节最开始的那幅图所示，映射到高维空间后，相关特征便被分开了，也就达到了分类的目的)；
\item 但进一步，如果凡是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到可怕的(如上文中19维乃至无穷维的例子)。那咋办呢？
\item 此时，核函数就隆重登场了，核函数的价值在于它虽然也是讲特征进行从低维到高维的转换，但核函数绝就绝在它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就如上文所说的避免了直接在高维空间中的复杂计算。
\end{enumerate}






%\section{公式？！}
%
%\href{http://www.sciweavers.org/free-online-latex-equation-editor}{手点}
%
%
%\href{}{手写}
%
%\input{body/equation}
%
%
%
%\section{图表}
%\subsection{插图}
%
%\begin{figure}[H]
%\includegraphics[width=8cm]{figure1.jpg}
%\caption{Shubert Function}
%\end{figure}
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{figure}[H]
%\includegraphics[width=8cm]{figure1.jpg}
%\caption{Shubert Function}
%\end{figure}
%\end{lstlisting}
%
%\begin{figure}[H]
%\centering
%\includegraphics[width=8cm]{figure1.jpg}
%\caption{Shubert Function}
%\end{figure}
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{figure}[H]
%\centering
%\includegraphics[width=8cm]{figure1.jpg}
%\caption{Shubert Function}
%\end{figure}
%\end{lstlisting}
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{figure}[H]
%	\begin{center}
%	\includegraphics[width=8cm]{figure1.jpg}
%	\caption{Shubert Function}
%	\end{center}
%\end{figure}
%\end{lstlisting}
%
%
%\begin{figure}[H]
%\centering
%\subfigure[恩恩]{
%\includegraphics[width=4cm]{figure1.jpg}
%\includegraphics[width=4cm]{figure21.jpg}
%}
%\subfigure[呵呵]{
%\includegraphics[width=4cm]{figure1.jpg}
%\includegraphics[width=4cm]{figure1.jpg}
%}
%\caption{The trace of NO.2 player , NO.5 player and ball from cycle 238 to cycle 258}
%\end{figure}
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{figure}[H]
%\centering
%\subfigure[ 恩恩]{
%\includegraphics[width=4cm]{figure1.jpg}
%\includegraphics[width=4cm]{figure21.jpg}
%}
%\subfigure[ 呵呵]{
%\includegraphics[width=4cm]{figure1.jpg}
%\includegraphics[width=4cm]{figure1.jpg}
%}
%\caption{The trace of NO.2 player , NO.5 player and ball from cycle 238 to cycle 258}
%\end{figure}
%\end{lstlisting}
%
%\begin{figure}[H]
%\centering
%\subfigure[the first subfigure]{
%\begin{minipage}[b]{0.2\textwidth}
%\includegraphics[width=1\textwidth]{figure1} \\
%\includegraphics[width=1\textwidth]{figure21}
%\end{minipage}
%}
%\subfigure[the second subfigure]{
%\begin{minipage}[b]{0.2\textwidth}
%\includegraphics[width=1\textwidth]{figure1} \\
%\includegraphics[width=1\textwidth]{figure1}
%\end{minipage}
%}
%\end{figure}
%
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{figure}[H]
%\centering
%\subfigure[the first subfigure]{
%\begin{minipage}[b]{0.2\textwidth}
%\includegraphics[width=1\textwidth]{figure1} \\
%\includegraphics[width=1\textwidth]{figure21}
%\end{minipage}
%}
%\subfigure[the second subfigure]{
%\begin{minipage}[b]{0.2\textwidth}
%\includegraphics[width=1\textwidth]{figure1} \\
%\includegraphics[width=1\textwidth]{figure1}
%\end{minipage}
%}
%\end{figure}
%\end{lstlisting}
%
%
%\subsection{画表}
%
%
%\begin{table}[H]
%\centering
%\caption{Comparison of algorithm efficiency between AINGA and SIGA}
%\begin{tabular}{c|c|c}
%\hline
%Algorithm & Average steps & Success rate /\%\\\hline
%AINGA & 92 & 100\\\hline
%SIGA & 213 & 60\\\hline
%\end{tabular}
%\end{table}
%
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{table}[H]
%\centering
%\caption{Comparison of algorithm efficiency between AINGA and SIGA}
%\begin{tabular}{c|c|c}
%\hline
%Algorithm & Average steps & Success rate /\%\\\hline
%AINGA & 92 & 100\\\hline
%SIGA & 213 & 60\\\hline
%\end{tabular}
%\end{table}
%\end{lstlisting}
%
%
%
%\begin{table}[H]
%\centering
%\caption{Comparison of tackle success rate between the team based on AINGA and the team based on SGA.}
%\begin{tabular}{c|c|c|c|c}
%\hline
%Team & \tabincell{c}{50\\matches} & \tabincell{c}{100\\matches} & \tabincell{c}{200\\matches} & \tabincell{c}{Success \\rate/\%}  \\ \hline
%AINGA & 89\% & 91\% & 90\% & 90\% \\\hline
%Q-Learning & 84\% & 86\% & 83\% & 84.3\% \\\hline
%\end{tabular}
%\end{table}
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\begin{table}[H]
%\centering
%\caption{Comparison of tackle success rate between the team based on AINGA and the team based on SGA.}
%\begin{tabular}{c|c|c|c|c}
%\hline
%Team & \tabincell{c}{50\\matches} & \tabincell{c}{100\\matches} & \tabincell{c}{200\\matches} & \tabincell{c}{Success \\rate/\%}  \\ \hline
%AINGA & 89\% & 91\% & 90\% & 90\% \\\hline
%Q-Learning & 84\% & 86\% & 83\% & 84.3\% \\\hline
%\end{tabular}
%\end{table}
%\end{lstlisting}
%
%\section{参考文献}
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%@article{name1,
%author = {作者, 多个作者用 and 连接},
%title = {标题},
%journal = {期刊名},
%volume = {卷20},
%number = {页码},
%year = {年份},
%abstract = {摘要, 这个主要是引用的时候自己参考的, 这一行不是必须的}
%}
%
%@book{name2,
%author ="作者",
%year="年份2008",
%title="书名",
%publisher ="出版社名称"
%}
%\end{lstlisting}
%
%最简单的使用方法
%
%
%\begin{lstlisting}[language=TeX,numbers=none,frame=lrtb,keywords={begin},label=Gamma,caption=Gamma]
%\bibitem{CK1}Shing-jun Ren and Hai-de Huang (2001). “A Robot Path
%Planning Algorithm Based On Grid Expansion.” Journal of
%Harbin Institute of Technology. Vol.9,No. 11, pp. 68-72.
%\end{lstlisting}
%
%\begin{thebibliography}{11}
%\bibitem{CK1}Shing-jun Ren and Hai-de Huang (2001). “A Robot Path
%Planning Algorithm Based On Grid Expansion.” Journal of
%Harbin Institute of Technology. Vol.9,No. 11, pp. 68-72.
%\bibitem{CK2} Hong-yan Shi, Chang-zhi Sun et al. (2006). “Chaotic
%Potential Field Method and Application in RobotSoccer
%Game.” Proceedings of the 6th World Congress on
%Intelligent Control andAutomation, Dalian, China, June
%2006.
%
%\end{thebibliography}
\end{document}
